#+TITLE: Een libkmint tutorial
#+AUTHOR: Jeroen de Haas

* Introductie
  =libkmint= is een C++-bilbiotheek waarmee je de opdrachten voor het vak
  kunstmatige intelligentie kan maken. Het staat je vrij om een andere
  bibliotheek te gebruiken of zelf iets te schrijven zolang de bibliotheek van
  jouw keuze de technieken die in dit vak worden behandeld niet al
  implementeert.

* Structuur van het project
  Het project op Blackboard is onderverdeeld in een bibliotheek
  =libkmint= en een applicatie =sim=. Daarnaast bevat de map
  =dependencies= de SDL2 en SDL2_image bibliotheek voor
  Windows. Linux- en macOS-gebruikers moeten deze bibliotheken via een
  /package manager/ installeren.
  
  Je plaatst jouw eigen bronbestanden in de map =sim/src=. De code onder
  =libkmint= laat je best ongemoeid. Mochten jij of een van je collega's
  namelijk een fout ontdekken, dan krijgen jullie van ons een nieuwe versie
  van =libkmint=. 
  
  Als je een cpp-bestand toevoegt aan =sim/src= dan dien je ook
  =sim/CMakeLists.txt= aan te passen. In dat bestand vind je nu
  onderstaande code:
  #+BEGIN_SRC cmake
    add_executable(sim
      src/main.cpp
      src/sim/hare.cpp
      src/sim/cow.cpp)
  #+END_SRC
  Voeg je het bestand =astar.cpp= toe, moet deze als volgt aan het project
  worden gekoppeld:
  #+BEGIN_SRC cmake
    add_executable(sim
      src/main.cpp
      src/sim/astar.cpp # NIEUWE REGEL!
      src/sim/hare.cpp
      src/sim/cow.cpp)
  #+END_SRC
  
  *Let op:* Headers moeten /niet/ aan het project worden gekoppeld. Deze
  worden indirect meegenomen via =include=-directives.

** CLion
  Het project kan onder Linux en macOS met CLion worden geopend en
  gecompileerd. De combinatie van CLion en Windows is niet getest.

** Visual Studio 
  Onder Windows wordt Visual Studio 2017 ondersteund. Om het
  project in Visual Studio 2017 te openen kies je "File -> Open -> CMake" en
  selecteer je het =CMakeLists.txt= bestand in de hoofdmap. *Let op:* Open niet
  de gelijknamige bestanden in de mappen =sim= of =libkmint=. 

  Kies na het openen =sim.exe= als "Startup Item" en druk op de knop met
  het groene afspeelsymbool. Als het goed is verschijnt een zwart venster.
  
  

  
* Terminologie
  =libkmint= gebruikt de volgende begrippen:
  - stage :: Een stage (/podium/) is de spelwereld waarop zich alle agenten
             bevinden. In de regel geldt dat alles wat beweegt, interageert
             met de wereld of getekend moet worden op het podium geplaatst
             moet worden.
  - actor :: Een actor (/acteur/) staat op het podium. Je agenten (de koe en
             de haas) zijn actors. Daarnaast zijn zaken als de achtergrond van
             de speelwereld en de graaf ook actors. Actors hoeven dus niet
             dynamisch van aard te zijn.
  - drawable :: Elke actor moet gekoppeld zijn aan een =drawable=. =drawable=
                is een basisklasse voor objecten die getekend worden op het
                scherm. Afgeleide klassen moeten de functie =draw=
                implementeren waarin getekend wordt.
  - graph :: een graph representeert een graaf.
  - map :: een map, oftewel kaart, is een combinatie van een graaf en een
           afbeelding die dient als achtergrond.

             
             
* Hello, world
  Hieronder staat een simpel "hello world"-programma dat een venster opent en
  wacht tot de gebruiker op de =q= drukt:

  #+BEGIN_SRC cpp -n
    #include "kmint/graphics.hpp"      // kleuren en afbeeldingen
    #include "kmint/main.hpp"          // voor de main loop
    #include "kmint/math/vector2d.hpp" // voor window en app
    #include "kmint/play.hpp"          // voor stage
    #include "kmint/ui.hpp"            // voor window en app

    using namespace kmint; // alles van libkmint bevindt zich in deze namespace

    int main() {
      // een app object is nodig om
      ui::app app{};

      //  maak een venster aan
      ui::window window{app.create_window({1024, 768}, "hello")};

      // maak een podium aan
      play::stage s{ {1024, 768 } };

      // Maak een event_source aan (hieruit kun je alle events halen, zoals
      // toetsaanslagen)
      ui::events::event_source event_source{};

      // main_loop stuurt alle actors aan.
      main_loop(s, window, [&](delta_time dt, loop_controls &ctl) {
        // gebruik dt om te kijken hoeveel tijd versterken is
        // sinds de vorige keer dat deze lambda werd aangeroepen
        // loop controls is een object met eigenschappen die je kunt gebruiken om de
        // main-loop aan te sturen.

        for (ui::events::event &e : event_source) {
          // event heeft een methjode handle_quit die controleert
          // of de gebruiker de applicatie wilt sluiten, en zo ja
          // de meegegeven functie (of lambda) aanroept om met het
          // bijbehorende quit_event
          //
          e.handle_quit([&](ui::events::quit_event qe) {
            ctl.quit = true;
          });
          e.handle_key_up([&](ui::events::key_event k) {
            // jouw code hier
          });
        }
      });
    }
  #+END_SRC
  
* Een actor toevoegen
  In deze paragraaf voegen we een actor toe aan de spelwereld. Een actor moet
  de van de klasse =kmint::play::actor= overerven. In dit voorbeeld erven we
  over van =free_roaming_actor=, een basisklasse voor actors die op een
  willekeurige positie kunnen staan.
  
  Om een actor te tekenen, moet je daarnaast een klasse maken die is afgeleid
  van =kmint::ui::drawable=. Deze abstracte klasse bevat een methode =draw=
  die elk frame wordt aangeroepen. Via de meegegeven =frame= referentie kun je
  tekenen. Onderstaande code bevat de code voor een simpele =drawable= en een
  eerste =actor=.
  
  Plaats deze code boven de =sim/include/rectangle_drawable.hpp=. Deze
  header doet een aantal dingen:

  1. Deze importeert de definitie van de klasse =drawable=. Zonder
     deze definitie kunnen we geen afgeleide klasse maken.
  2. Daarnaast worden twee klasse alvast gedeclareerd, namelijk
     =actor= in =kmint::play= en =frame= in =kmint::ui=. Omdat we deze
     alleen via een pointer of reference benaderen, hebben we hier nog
     geen /definitie/ van deze klassen nodig.
  3. Als laatste definieert deze de klasse =rectangle_drawable= in
     onze eigen namespace =sim=.

  #+begin_src cpp
    #ifndef SIM_RECTANGLE_DRAWABLE_HPP
    #define SIM_RECTANGLE_DRAWABLE_HPP

    #include "kmint/ui/drawable.hpp"

    // forward declarations
    namespace kmint {
      namespace play {
        class actor;
      }
      namespace ui {
        class frame;
      }
    }

    namespace sim {

    class rectangle_drawable : public kmint::ui::drawable {
    public:
      rectangle_drawable(kmint::play::actor const &actor) : drawable{}, actor_{&actor} {}
      void draw(kmint::ui::frame &f) const override;

    private:
      kmint::play::actor const *actor_;
    };

    }

    #endif
  #+end_src
  
  Rest ons nog om de member function =draw= te implementeren. Dit doen
  we in het bijbehorende =cpp=-bestand. Hiervoor gebruiken we member
  functions en functionaliteit van zowel de =ui= als =play=
  namespaces. Daarom importeren we deze:
  
  #+begin_src cpp
    #include "sim/rectangle_drawable.hpp"
    #include "kmint/ui.hpp"
    #include "kmint/play.hpp"

    namespace sim {

    void rectangle_drawable::draw(kmint::ui::frame &f) const {
      f.draw_rectangle(actor_->location(), {10.0, 10.0}, kmint::graphics::colors::white);
    }

    }
  #+end_src
  
  Nu gaan we de actor maken, plaats daarvoor volgende code in
  =sim/include/hello_actor.hpp=
  
  #+begin_src cpp
    #ifndef SIM_HELLO_ACTOR_HPP
    #define SIM_HELLO_ACTOR_HPP

    #include "kmint/play.hpp"
    #include "sim/rectangle_drawable.hpp"

    namespace sim {

    class hello_actor : public kmint::play::free_roaming_actor {
    public:
      hello_actor(kmint::math::vector2d location);
      kmint::ui::drawable const &drawable() const override;
      void move(kmint::math::vector2d delta);

    private:
      rectangle_drawable drawable_;
    };

    } // namespace sim

    #endif /* SIM_HELLO_ACTOR_HPP */
  #+end_src
  
  Rest ons nog de member functions =drawable= en =move= te
  implementeren. Dit doen we in =sim/src/sim/hello_actor.cpp=
  
  #+begin_src cpp
    #include "sim/hello_actor.hpp"

    namespace sim {

    hello_actor::hello_actor(kmint::math::vector2d location)
        : free_roaming_actor{location}, drawable_{*this} {}

    kmint::ui::drawable const &hello_actor::drawable() const { return drawable_; }

    void hello_actor::move(kmint::math::vector2d delta) {
      location(location() + delta);
    }

    } // namespace sim
  #+end_src
  
  Om deze actor vervolgens op je =stage= te plaatsen, gebruik je de
  functie =stage::build_actor=. Deze functie bouwt een actor en geeft
  een referentie naar de gebouwde =actor= terug. Jouw code zal dus
  /nooit/ de eigenaar zijn van welke =actor= dan ook. Het eigendom van
  deze objecten ligt bij =stage=. 
  
  Allereerst moeten we ervoor zorgen dat de definitie van
  =hello_actor= bekend is. Daarvoor voeg je volgende include toe aan
  =sim/src/main.cpp=:
  
  #+begin_src cpp
    #include "sim/hello_actor.hpp"
  #+end_src
  
  Vervolgens kun je de =actor= toevoegen aan je =stage=. Dit doe je
  dus na de initialisatie van je =stage=:

  #+BEGIN_SRC cpp
      math::vector2d center{512.0, 384.0};
      auto &my_actor = s.build_actor<sim::hello_actor>(center);
  #+END_SRC
  
  Hoe werkt =build_actor=? =build_actor= is een template
  function. Tussen de vishaken geef je aan welke klasse je wilt
  maken. Alle argumenten die je aan de constructor van die klasse wilt
  meegeven, geef je in dezelfde volgorde mee aan =build_actor=. Deze
  zal ze vervolgens doorsturen naar de constructor van de opgegeven
  klasse. Dit patroon staat bekend als /perfect forwarding/.
  
  
* Interactie
  We gaan er nu voor zorgen dat je het vierkantje op je scherm kunt
  bewegen met de pijltjes toetsen. Hiervoor moeten we de member
  function =move= van onze =hello_actor= aanroepen.
  #+BEGIN_SRC cpp
      void move(math::vector2d delta) { location(location() + delta); }
  #+END_SRC
  
  Pas de for-lus aan in =main_loop=:
  #+BEGIN_SRC cpp
        for (ui::events::event &e : event_source) {
          // event heeft een methode handle_quit die controleert
          // of de gebruiker de applicatie wilt sluiten, en zo ja
          // de meegegeven functie (of lambda) aanroept om met het
          // bijbehorende quit_event
          //
          e.handle_quit([&ctl](ui::events::quit_event qe) {
            ctl.quit = true;
          });
          e.handle_key_up([&my_actor](ui::events::key_event k) {
            switch (k.key) {
            case ui::events::key::up:
              my_actor.move({0, -5.0f});
              break;
            case ui::events::key::down:
              my_actor.move({0, 5.0f});
              break;
            case ui::events::key::left:
              my_actor.move({-5.0f, 0});
              break;
            case ui::events::key::right:
              my_actor.move({5.0f, 0});
              break;
            default:
              break;
            }
          });
        }
  #+END_SRC

  Als het goed is, kun je het vierkantje nu verplaatsen met de pijltjes toetsen!

* Een kaart toevoegen
  
  Een kaart is een combinatie van een graaf met een achtergrondafbeelding. Een kaart
  is een tweedimensionaal grid van vakjes. Een deel van deze vakjes zijn
  verbonden met hun linker-, rechter-, boven- en/of onderbuur. Zo vormen deze
  vakjes samen een graaf.
  
  Een kaart wordt ingelezen uit een string. Hieronder zie je een voorbeeld,
  verderop wordt per regel uitgelegd waar deze voor staat.
  #+BEGIN_SRC text -n
    40 6 32
    resources/map3.png
    G 1 1
    C 1 2
    W 0 0
    B 1 8

    GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
    GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
    GGGGGGGGGGGGGGGGGGGGGGGGGGCCCCCGGGGGGGGG
    GGGGGGGGGGGGGGGGGGGGGGGGGGCCCCCGGGGGGGGG
    GGGGGGGGGGGGGGGGGGGGGGGGGGCCCCCGGGGGGGGG
    WWWWWWWWWBWWWWWWWWWWWWGGGGGGGGGGGGGGGGGG
  #+END_SRC
  
  - 1 :: De afmetingen van de kaart. Deze kaart is 40 vakjes breed, 6 vakjes
         hoog en elk vakje is 32 bij 32 pixels groot
  - 2 :: Het pad naar de achtergrondafbeelding
  - 3 t/m 6 :: Een beschrijving van de vakjes. Elk vakje heeft een symbool
               ('G', 'C', 'W' of 'B'). Dit symbool wordt gevolgd door een 0 of
               een 1 die aangeeft of het vakje begaanbaar is. Een 0 betekent
               niet begaanbaar, een 1 betekent begaanbaar. Het laatste getal
               geeft hoe moeilijk het is om over dit vakje te bewegen. Het
               kost twee maal zoveel tijd om een vakje met een
               moeilijkheidsgraad van 2 te verlaten.
  - 7 :: Een witregel die de informatie over de kaart scheidt van de echte kaart
  - 8 t/m 13 :: Een beschrijving van de kaart. Elke regel correspondeert met
                een rij op de kaart, elk symbool met een vakje.
                
** Inlezen
   Om een kaart uit te lezen is het noodzakelijk volgende header te in te voegen:
   #+BEGIN_SRC cpp
     #include "kmint/map/map.hpp"
   #+END_SRC
   
   De definitie van een kaart kun je direct in je programma
   plaatsen. Onderstaande code laat zien hoe je dit met behulp van een /raw
   string literal[fn:1]/ kunt doen:
   #+BEGIN_SRC cpp
     static const char *map_description = R"graph(32 24 32
     resources/firstmap.png
     G 1 1
     C 1 1
     H 1 1
     W 0 0
     B 1 8

     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
     WWWHGGGGGGGGGGGGGGGGGGGGGGGGHWWW
     WWWGGGGGGGGGGGGGGGGGGGGGGGGGGWWW
     WWWGGGGGGGGGGGGGBGGGGGGGGGGGGWWW
     WWWGGGGGGWWWWWWWBWWWWWWGGGGGGWWW
     WWWGGGGGGWWWWWWWBWWWWWWGGGGGGWWW
     WWWGGGGGGWWWWWWWBWWWWWWGGGGGGWWW
     WWWGGGGGGWWWWWGGBGWWWWWGGGGGGWWW
     WWWGGGGGGWWWWWGGGGWWWWWGGGGGGWWW
     WWWGGGGGGWWWWWGGGGWWWWWGGGGGGWWW
     WWWGGGGGBBBBBBBGCGGGGGGGGGGGGWWW
     WWWGGGGGGWWWWWGGGGWWWWWGGGGGGWWW
     WWWGGGGGGWWWWWGGBGWWWWWGGGGGGWWW
     WWWGGGGGGWWWWWWWBWWWWWWGGGGGGWWW
     WWWGGGGGGWWWWWWWBWWWWWWGGGGGGWWW
     WWWGGGGGGWWWWWWWBWWWWWWGGGGGGWWW
     WWWGGGGGGGGGGGGGBGGGGGGGGGGGGWWW
     WWWGGGGGGGGGGGGGGGGGGGGGGGGGGWWW
     WWWHGGGGGGGGGGGGGGGGGGGGGGGGHWWW
     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
     WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
     )graph";
   #+END_SRC
   
   Met volgende code lees je de kaart vervolgens uit:
   #+BEGIN_SRC cpp
     map::map m{map::read_map(map_description)};
   #+END_SRC
   
   De afbeelding en de graaf moeten elk onafhankelijk worden
   getekend. Hiervoor gebruik je twee verschillende soorten actors. Een
   =map_actor= tekent de graaf die hoort bij de kaart, en een =background=
   tekent de achtergrond. Zorg ervoor dat je eerst de background aan je stage
   toevoegt, gevolgd door de graaf. Daarna kun je andere actors toevoegen:
   #+BEGIN_SRC cpp
     s.build_actor<play::background>(
       math::size(1024, 768),
       graphics::image{m.background_image()});
     s.build_actor<play::map_actor>(
       math::vector2d{0.0f, 0.0f},
       m.graph());
   #+END_SRC
   
   Als het goed is, zie je nu volgend programma:

   [[./resources/screenshot.png]]
   
** De structuur van een kaart
   Een =map= bestaat uit twee delen, een graaf van het type =map_graph= en het
   pad naar een achtergrondafbeelding. De graaf haal je op via de functie
   =map::graph()=. Deze graaf kun je zien als een array van knopen van het
   type =map_node=. Het aantal knopen in een kaart kun je opvragen met de
   functie =map_graph::num_nodes()=. De nodes kun je ophalen met de subscript
   operator, bijvoorbeeld zo:
   #+BEGIN_SRC cpp
     // laad een kaart
     map::map m{map::read_map(map_description)};
     auto &graph = m.graph();
     for (std::size_t i = 0; i < graph.num_nodes(); ++i) {
       std::cout << "Knoop op: " << graph[i].location().x() << ", "
                 << graph[i].location().y() << "\n";
     }
   #+END_SRC
   
   Een knoop kun je op zijn beurt weer zien als een array van kanten van het
   type =map_edge=. Het aantal kanten aan een knoop vraag je op met
   =map_node::num_edges= en met de subscript operator kun je een van de kanten opvragen:
   #+BEGIN_SRC cpp
     auto &node = graph[0];
     for (std::size_t i = 0; i < node.num_edges(); ++i) {
       auto &from = node[i].from();
       auto &to = node[i].to();
       std::cout << "Kant van: " << from.location().x() << ", "
                 << from.location().y() << " naar " << to.location().x() << ", "
                 << to.location().y() << "\n";
     }
   #+END_SRC
   
   Elke kant heeft een gewicht. Dit geeft aan hoe lastig het is voor een actor
   om zich via die kant te verplaatsen. De kanten horende bij de brug hebben
   een gewicht van acht. Je kunt het gewicht ophalen met de functie =weight=:
   #+BEGIN_SRC cpp
     auto &node = graph[0];
     auto &edge = node[0];
     float weight = edge.weight();
   #+END_SRC
   
   *Voor gevorderden:* Wil je deze klassen gebruiken in combinatie met
   STL-algoritmen dan kan dat. =map_graph= en =map_node= bieden member
   functions =begin= en =end= die de juiste iterators teruggeven.

   
* Een actor op de graaf
  Een volgende stap is om een actor te laten bewegen over de graaf. In het
  midden van de kaart zie je een modderhoop. In de tekstuele beschrijving van
  de kaart is dit punt met de letter =C= aangegeven. Dit is het vertrekpunt van de
  koe. Zij zal het eiland vanuit dit punt over het eiland gaan dwalen.
  
  Eerst schrijven we een functie die de de kaart afzoekt naar het beginpunt
  van de koe. Plaats deze functie boven je =main= functie:

  #+BEGIN_SRC cpp
    map::map_node &find_cow_node(map::map_graph &graph) {
      for (std::size_t i = 0; i < graph.num_nodes(); ++i) {
        if (graph[i].node_info().kind == 'C') {
          return graph[i];
        }
      }
      throw "could not find starting point";
    }
  #+END_SRC
  
  In onze =main= functie roepen we deze functie aan
  #+BEGIN_SRC cpp
    auto &cow_node = find_cow_node(m.graph());
  #+END_SRC

  Actors die zich over de kaart bewegen worden afgeleid van de klasse
  =map_actor=. We maken nu een klasse koe die elke seconde een stap op de
  kaart zet. Plaats hiervoor de volgende code in
  =sim/include/sim/cow.hpp=:

  #+BEGIN_SRC cpp
    #ifndef SIM_COW_HPP
    #define SIM_COW_HPP

    #include "kmint/map/map.hpp"
    #include "kmint/play.hpp"
    #include "kmint/primitives.hpp"

    namespace sim {

    class cow : public kmint::play::map_bound_actor {
    public:
      cow(kmint::map::map_node &initial_node);
      // wordt elke game tick aangeroepen
      void act(kmint::delta_time dt) override;
      kmint::ui::drawable const &drawable() const override { return drawable_; }
      // als incorporeal false is, doet de actor mee aan collision detection
      bool incorporeal() const override { return false; }
      // geeft de de lengte van een zijde van de collision box van deze actor terug.
      // Belangrijk voor collision detection
      kmint::scalar collision_range() const override { return 16.0; }

    private:
      // hoeveel tijd is verstreken sinds de laatste beweging
      kmint::delta_time t_passed_{};
      // weet hoe de koe getekend moet worden
      kmint::play::image_drawable drawable_;
    };

    } // namespace sim

    #endif
  #+END_SRC
  
  =sim/src/sim/cow.cpp= ziet er als volgt uit:
  #+BEGIN_SRC cpp
    #include "sim/cow.hpp"
    #include "kmint/random.hpp"
    using namespace kmint;

    namespace sim {

    static const char *cow_image = "resources/cow.png";
    cow::cow(map::map_node &initial_node)
        : play::map_bound_actor{initial_node}, drawable_{*this,
                                                         kmint::graphics::image{
                                                             cow_image, 0.1}} {}

    void cow::act(delta_time dt) {
      t_passed_ += dt;
      if (to_seconds(t_passed_) >= 1) {
        // pick random edge
        int next_index = random_int(0, node().num_edges());
        this->node(node()[next_index].to());
        t_passed_ = from_seconds(0);
      }
    }

    }
  #+END_SRC
  
  Laad =cow.hpp= vervolgens in =main.cpp=:
  #+BEGIN_SRC cpp
    #include "sim/cow.hpp"
  #+END_SRC
  
  En plaats de koe op het podium:
  #+BEGIN_SRC cpp
    s.build_actor<sim::cow>(cow_node);
  #+END_SRC
  
  
* Collision detection
  Naast de koe bevindt zich ook een haas op de kaart. De koe moet deze haas
  vangen. De haas bevindt zich op een van de vier uithoeken van de kaart, deze
  zijn te herkennen aan de =H= in de tekstuele representatie.
  
  De haas is een =map_bound_actor=. De header file voor de haas wordt =sim/include/sim/hare.hpp=:
  #+BEGIN_SRC cpp
    #ifndef SIM_HARE_HPP
    #define SIM_HARE_HPP

    #include "kmint/map/map.hpp"
    #include "kmint/play.hpp"
    #include "kmint/primitives.hpp"

    namespace sim {

    class cow;

    class hare : public kmint::play::map_bound_actor {
    public:
      hare(kmint::map::map_graph &g);
      void act(kmint::delta_time dt) override;
      kmint::ui::drawable const &drawable() const override { return drawable_; }
      void set_cow(cow const &c) { cow_ = &c; }
      bool incorporeal() const override { return false; }
      kmint::scalar collision_range() const override { return 16.0; }

    private:
      kmint::play::image_drawable drawable_;
      kmint::map::map_graph *graph_;
      cow const *cow_{};
    };

    } // namespace sim

    #endif // SIM_HARE_HPP
  #+END_SRC
  
  De haas blijft net zolang staan tot de koe haar vangt. Op dat moment wordt
  ze verplaatst naar een andere geschikte locatie. De haas wordt als volgt
  ge√Ømplementeerd:
  #+BEGIN_SRC cpp
    #include "sim/hare.hpp"
    #include "kmint/random.hpp"
    #include "sim/cow.hpp"
    namespace sim {

    using namespace kmint;

    static const char *hare_image = "resources/hare.png";

    std::size_t random_hare_node(map::map_graph const &graph) {
      int r = kmint::random_int(0, 3);
      for (std::size_t i = 0; i < graph.num_nodes(); ++i) {
        if (graph[i].node_info().kind == 'H') {
          if (r == 0)
            return i;
          else
            --r;
        }
      }
      throw "could not find node for hare";
    }

    hare::hare(map::map_graph &g)
        : play::map_bound_actor{g[random_hare_node(g)]},
          drawable_{*this, kmint::graphics::image{hare_image}}, graph_{&g} {}

    void hare::act(kmint::delta_time dt) {
      for (std::size_t i = 0; i < num_colliding_actors(); ++i) {
        auto &a = colliding_actor(i);
        if (cow_ != nullptr && &a == cow_) {
          auto &g = *graph_;
          node(g[random_hare_node(g)]);
          return;
        }
      }
    }
    } // namespace sim
  #+END_SRC
  
  Pas tenslotte de code in =main.cpp= aan opdat de haas weet wie de koe is. De
  code die de koe en de haas op het podium plaatst hoort er als volgt uit te
  zien:
  #+BEGIN_SRC cpp
    auto &cow_node = find_cow_node(m.graph());
    auto &my_cow = s.build_actor<sim::cow>(cow_node);
    auto &my_hare = s.build_actor<sim::hare>(m.graph());
    my_hare.set_cow(my_cow);
  #+END_SRC

* The end
  Je hebt nu een werkend basisprogramma waarmee je aan de opdrachten voor week
  1 kunt gaan werken. Succes!
  

  

* Footnotes

[fn:1] Zie [[https://en.cppreference.com/w/cpp/language/string_literal][dit voorbeeld op cppreference.com]].



